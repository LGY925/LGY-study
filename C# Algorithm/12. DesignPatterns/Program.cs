namespace _12._DesignPatterns
{
    internal class Program
    {
        // 싱글톤 패턴
        //개요에서 설명이 나왔던 싱글톤 패턴은 게임에서 유일한 인스턴스를 보장하고,
        //전역적인 접근이 필요한 경우에 사용되는 패턴입니다.
        //싱글톤 패턴은 클래스의 인스턴스가 하나만 생성되도록 보장하고,
        //어디서든 동일한 인스턴스에 접근할 수 있게 합니다.
        //예를 들어, 게임 매니저, 자원 관리자 등에서 활용됩니다.

        // 상태 패턴
        // 게임에서 오브젝트의 동작이 상태에 따라 달라지는 경우 사용되는 패턴입니다.
        // 상태 패턴은 각 상태를 클래스로 구현하고, 상태에 따라 다른 동작을 수행합니다.
        // 예를 들어, 캐릭터의 이동 상태, 공격 상태, 대기 상태 등을 다루는 데 유용합니다.
        // 캐릭터의 상태를 객체로 구현하게 되면,
        // 추후 새로운 상태가 추가 되어도
        // 이 상태를 사용하는 캐릭터 클래스의 코드를 대폭 수정할 필요 없이 유연하게 대처가 가능합니다.

        // 오브젝트 풀 패턴
        // 게임에서 반복적으로 생성되고 소멸되는 객체들을 효율적으로 관리하기 위한 패턴입니다.
        // 객체 풀 패턴은 미리 생성된 객체들을 풀에 저장해두고,
        // 필요할 때마다 객체를 재사용하여 생성 및 소멸의 오버헤드를 줄입니다.
        // 게임에서 객체는 정말 많은데,
        // 이 객체들을 필요한 상황마다 생성하여 사용하거나,
        // 사용이 종료되는 순간순간 없애는 작업이 반복된다면 꽤 큰 부하가 걸릴것입니다.
        // 미리 큰 메모리 공간을 확보해 둔 후에,
        // 객체의 사용이 끝나도 객체를 지우는 것이 아닌,
        // 잠시 비활성화 해 두었다가 재활용하는 방법으로 사용하면 성능상 큰 이득을 볼 수 있습니다.

        // 컴포지넌트 패턴
        // 게임 오브젝트의 동작과 기능을 구현하는 데 사용되는 패턴입니다. 각각의 게임 오브젝트는 여러 개의 컴포넌트로 구성되며, 컴포넌트는 독립적으로 동작하고 상호작용합니다.
        // 다시 말해, 자동차라는 객체가 있을 경우, 이 객체를 만드는 방법으로 엔진객체, 휠 객체, 미션 객체, 브레이크 객체 등
        // 세분화 된 객체들을 조립하여 하나의 객체를 구성해 나가는 패턴입니다.

        // 옵저버 패턴
        // 이 패턴은 객체 간의 일대다 관계를 구성하여, 한 객체의 상태 변화에 따라 다른 객체들이 자동으로 업데이트되도록 하는 것을 목적으로 합니다.
        // 옵저버 패턴은 주제(Subject)와 옵저버(Observer)라는 두 가지 주요 요소로 구성됩니다. 주제는 상태를 가지며,
        // 상태가 변경될 때 옵저버에게 알립니다. 옵저버는 주제를 구독하고,
        // 주제의 상태가 변경되면 업데이트를 수신하여 필요한 동작을 수행합니다.
        // 플레이어의 정보를 표시하는 UI가 있다고 가정 시,
        // 이 UI가 플레이어의 정보를 항시 받아 출력하는 형태는 비효율적일것입니다.
        // 변동사항이 있을때만, 변동사항이 있다는 것을 관련된 객체들에게 전달시키는 방식을 채용하게 되면 객체간의 결합도를 낮추고,
        // 유연성 및 확장성을 제공할 수 있습니다. 이럴때 옵저버 패턴을 고려할 수 있습니다.

        static void Main(string[] args)
        {
            
        }
    }
}
